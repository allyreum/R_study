-- 참고: https://gent.tistory.com/339
-- LAG 함수 : 이전 행의 값을 리턴 -> LAG(empno) OVER(ORDER BY empno)  AS empno_prev
-- LEAD 함수: 다음 행의 값을 리턴 -> LEAD(empno) OVER(ORDER BY empno) AS empno_next
     

SELECT measured_at AS date_alert
FROM (
  SELECT
    measured_at,
    pm10,
    LAG(pm10, 1) OVER (ORDER BY measured_at) AS pm1,
    LAG(pm10, 2) OVER (ORDER BY measured_at) AS pm2
  FROM measurements
) t
WHERE pm10 >= 30
  AND pm10 > pm1
  AND pm1 > pm2;


-- 30㎍/㎥ 이상으로 2일 연속 ----------------------------------------------------------------------------------
오류원인
    1) where절( pm10 >= 30 )이 윈도우 함수보다 먼저 적용됨 → 마지막으로 걸어야 함
    2) next_date를 이미 lead(measured_at)로 만들어놓고, 다시 lead(measured_at)를 써서 비교함 → 같은 값을 두 번 참조
SQL 논리적 실행 순서: FROM → WHERE → GROUP BY → HAVING → SELECT(윈도우 함수 계산) → ORDER BY
JOIN 논리적 실행순서: FROM ─ JOIN / ON → WHERE → GROUP BY → HAVING → SELECT - 집계/윈도우 함수 → ORDER BY
---------------------------------------------------------------------------------------------------------- 

with temp as(
    select measured_at, 
        next_date,
        (lead(measured_at) over (order by measured_at) - next_date) as day_dif
FROM (
  select measured_at, 
        pm10,
        lead(measured_at) over (order by measured_at) as next_date
  from measurements
  where pm10 >= 30
) a
where (measured_at + 1) = next_date
)
select next_date as date_alert from temp where day_dif > 0 order by next_date


